/*-------------------------- Scanner(Lexical) -------------------------- */

/* Palabras Clave */
program      : 'p''r''o''g''r''a''m' ;
main         : 'm''a''i''n' ;
end          : 'e''n''d' ;
var          : 'v''a''r' ;
int          : 'i''n''t' ;
float        : 'f''l''o''a''t' ;
print        : 'p''r''i''n''t' ;
while        : 'w''h''i''l''e' ;
do           : 'd''o' ;
if           : 'i''f' ;
else         : 'e''l''s''e' ;
void         : 'v''o''i''d' ;

/* ID */
_lowcase     : 'a'-'z' ;
_upcase      : 'A'-'Z' ;
_digit       : '0'-'9' ;
id           : (_lowcase | _upcase) { (_lowcase | _upcase | _digit | '_') } ;

/* Constantes */
_special : ' ' | '!' | '#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' |
           ':' | ';' | '<' | '=' | '>' | '?' | '@' |
           '[' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~' ;
_chars       : _lowcase | _upcase | _special | _digit ;
cte_int      : _digit { _digit } ;
cte_float    : _digit { _digit } '.' _digit { _digit } ;
cte_string   : '"' {_chars} '"' ;

/* Operadores */
assign       : '=' ;
not_equal    : '!''=' ;
less_than    : '>' ;
more_than    : '<' ;
add          : '+' ;
rest         : '-' ;
multiply     : '*' ;
divide       : '/' ;

/* Simbolos especiales */
semicolon    : ';' ;
colon        : ':' ;
comma        : ',' ;
l_round_par  : '(' ;
r_round_par  : ')' ;
l_curly_par  : '{' ;
r_curly_par  : '}' ;
l_square_par : '[' ;
r_square_par : ']' ;

/* Ignorar */
!whitespace  : ' ' | '\t' | '\n' | '\r' ;

/* -------------------------- Parser (Syntax) -------------------------- */
<<
import(
    "baby_duck/semantics"
    "baby_duck/token"
)
>>


/* PROGRAM */
Program
    : program id semicolon Vars FunctionList main Body end
    <<
    func() (Attrib, error) {
        if $3 != nil {
            tablaGlobal := $3.(*semantics.Dictionary)
            for _, k := range tablaGlobal.Keys() {
                v, _ := tablaGlobal.Get(k)
                semantics.VarTable.Put(k, v)
            }
        }
        return nil, nil
    }()
    >>
    ;

FunctionList
    : Function FunctionList
    | "empty"
    ;

/* VARS */
Vars
    : var IdList colon Type semicolon
    <<
    func() (Attrib, error) {
        ids := $1.([]*token.Token)
        tipo := $3.(*token.Token)

        varNames := []string{}
        for _, tok := range ids {
            varNames = append(varNames, tok.IDValue())
        }

        // Verificaci칩n de duplicaci칩n de variables locales
        tablaLocal := semantics.NewDictionary()
        _, err := semantics.VarDeclaration(varNames, tipo.IDValue(), tablaLocal)
        if err != nil {
            return nil, err
        }

        return tablaLocal, nil
    }()
    >>
    | "empty"
    <<
    func() (Attrib, error) {
        return nil, nil
    }()
    >>
    ;

IdList
    : id IdListTail
    <<
    func() (Attrib, error) {
        tokens := []*token.Token{$0.(*token.Token)}
        tokens = append(tokens, $1.([]*token.Token)...)
        return tokens, nil
    }()
    >>;

IdListTail
    : comma id IdListTail
    <<
    func() (Attrib, error) {
        tokens := []*token.Token{$1.(*token.Token)}
        tokens = append(tokens, $2.([]*token.Token)...)
        return tokens, nil
    }()
    >>
    | "empty"
    <<
        func() (Attrib, error) {
            return []*token.Token{}, nil
        }()
    >>;

/* TYPE */
Type
    : int
    | float
    ;

/* FUNCS */
Function
    : void id l_round_par Params r_round_par l_square_par Vars Body r_square_par semicolon
    <<
    func() (Attrib, error) {
        nombre := $1.(*token.Token).IDValue()

        // Crear nueva tabla para variables locales
        tablaLocal := semantics.NewDictionary()

        // Procesar par치metros
        paramList := []semantics.VariableStructure{}
        if $3 != nil {
            paramList = $3.([]semantics.VariableStructure)
            for _, param := range paramList {
                if _, err := semantics.VarDeclaration([]string{param.Name}, param.Type, tablaLocal); err != nil {
                    return nil, err
                }
            }
        }

        // Declarar variables locales (Vars ya devuelve *Dictionary)
        if $6 != nil {
            vars := $6.(*semantics.Dictionary)
            for _, k := range vars.Keys() {
                v, _ := vars.Get(k)
                if _, err := semantics.VarDeclaration([]string{k}, v.(semantics.VariableStructure).Type, tablaLocal); err != nil {
                    return nil, err
                }
            }
        }

        // Registrar la funci칩n
        err := semantics.FuncDeclaration(nombre, paramList, tablaLocal)
        return nil, err
    }()
    >>
    ;

Params
    : ParamList
    | "empty"
    ;

ParamList
    : id colon Type ParamListTail
    <<
    func() (Attrib, error) {
        param := semantics.VariableStructure{
            Name: $0.(*token.Token).IDValue(),
            Type: $2.(*token.Token).IDValue(),
        }
        tail := $3.([]semantics.VariableStructure)
        return append([]semantics.VariableStructure{param}, tail...), nil
    }()
    >>
    ;

ParamListTail
    : comma id colon Type ParamListTail
    <<
    func() (Attrib, error) {
        param := semantics.VariableStructure{
            Name: $1.(*token.Token).IDValue(),
            Type: $3.(*token.Token).IDValue(),
        }
        tail := $4.([]semantics.VariableStructure)
        return append([]semantics.VariableStructure{param}, tail...), nil
    }()
    >>
    | "empty"
    <<
    func() (Attrib, error) {
        return []semantics.VariableStructure{}, nil
    }()
    >>
    ;

/* BODY */
Body
    : l_curly_par StatementList r_curly_par
    ;

StatementList
    : Statement StatementList
    | "empty"
    ;

/* STATEMENT */
Statement
    : Assign
    | Condition
    | Cycle
    | FCall
    | Print
    ;

/* ASSIGN */
Assign
    : id assign Expression semicolon
    ;

/* CONDITION */
Condition
    : if l_round_par Expression r_round_par Body Else semicolon
    ;

Else
    : else Body
    | "empty"
    ;

/* CYCLE */
Cycle
    : while l_round_par Expression r_round_par do Body semicolon
    ;

/* PRINT */
Print
    : print l_round_par PrintList r_round_par semicolon
    ;

PrintList
    : Expression PrintListTail
    | cte_string PrintListTail
    ;

PrintListTail
    : comma Expression PrintListTail
    | comma cte_string PrintListTail
    | "empty"
    ;

/* EXPRESSION */
Expression
    : Exp Operator Exp
    | Exp
    ;

Operator
    : less_than
    | more_than
    | not_equal
    ;

/* EXP */
Exp
    : Term ExpList
    ;

ExpList
    : add Term ExpList
    | rest Term ExpList
    | "empty"
    ;

/* TERM */
Term
    : Factor TermList
    ;

TermList
    : multiply Factor TermList
    | divide Factor TermList
    | "empty"
    ;

/* FACTOR */
Factor
    : l_round_par Expression r_round_par
    | Cte
    | id
    | add Factor
    | rest Factor
    ;

/* CTE */
Cte
    : cte_int
    | cte_float
    ;


/* F_CALL */
FCall
    : id l_round_par FCallList r_round_par semicolon
    ;

FCallList
    : Expression FCallListTail
    | "empty"
    ;

FCallListTail
    : comma Expression FCallListTail
    | "empty"
    ;